!function(t,a){"object"==typeof exports&&"undefined"!=typeof module?module.exports=a(require("lodash")):"function"==typeof define&&define.amd?define(["lodash"],a):(t="undefined"!=typeof globalThis?globalThis:t||self).Pn532Hf14a=a(t._)}(this,(function(t){"use strict";return class{name="hf14a";install(a,e){const{Packet:i,pn532:r,utils:n}=a,{retry:o}=n;function c(){return r?.$adapter?.isOpen?.()}async function s({maxTg:a=1,uid:e=new i,timeout:n}={}){const o=new i([136]);7===e.length?e=i.merge(o,e):10===e.length&&(e=i.merge(o,e.subarray(0,3),o,e.subarray(3)));const{data:c}=await r.inListPassiveTarget({maxTg:a,brTy:0,data:e,timeout:n}),s=t.times(c[0],(()=>({})));if(!t.find([0,8,12,10,14,11,15],(a=>{try{const e=t.map((16+a).toString(2).slice(-4),t.parseInt);if(e[0]+e[2]!==s.length)return!1;let i=1;for(let a=0;a<s.length;a++){const r=s[a];if(r.pack=c.subarray(i),r.pack[0]!==a+1)return!1;const n=r.pack[4];if(!t.includes([4,7,10],n))return!1;const o=e[2*a+1]?r.pack[5+n]:0,w=5+n+e[2*a+1]+o;if(r.pack=r.pack.subarray(0,w),r.atqa=r.pack.subarray(1,3),r.sak=r.pack.subarray(3,4),r.uid=r.pack.subarray(5,5+n),r.rats=r.pack.subarray(6+n),r.rats.length!==o)return!1;i+=w}return!0}catch(t){return!1}})))throw new Error("invalid hf14a target format");return s}async function w(){c()&&await r.inRelease().catch((()=>{}))}async function l({block:a=0,isKb:e=0,key:n,tg:o=1,uid:c,blocksPerSector:s=4}={}){if(!i.isLen(n,6))throw new TypeError("invalid key");if(!i.isLen(c))throw new TypeError("invalid uid");if(!t.includes([4,7,10],c.length))throw new TypeError("invalid uid length");e=e?1:0,a+=s-a%s-1;try{await r.inDataExchange({tg:o,data:new i([96+e,a,...n,...c.subarray(0,4)])})}catch(t){throw new Error(`Failed to auth block ${a}`)}}function d(a){const e=t.flatten(t.times(3,(t=>[(240&a[t])>>>4,15&a[t]])));return t.every([[1,2],[0,5],[3,4]],(([t,a])=>e[t]^15===e[a]))}function f(a){if(!t.isArray(a))throw new TypeError("invalid keys");return t.chain(a).filter((t=>i.isLen(t,6))).uniqWith(((t,a)=>t.isEqual(a))).value()}async function y(t,a){return(await o((async()=>{try{return await r.inDataExchange(t)}catch(e){if(!c())throw e;throw await r.inDeselect({tg:1}).catch((()=>{})),await l(a).catch((()=>{})),new Error(`Failed to read block ${t?.data?.[1]}`)}})))?.data}function u(t){return 0!==t.data[0]||i.isLen(t.data,17)}async function h(t,a){await o((async()=>{try{await r.inDataExchange(t)}catch(e){if(!c())throw e;throw await r.inDeselect({tg:1}).catch((()=>{})),await l(a).catch((()=>{})),new Error(`Failed to write block ${t?.data?.[1]}`)}}))}async function k(t,a,e){await o((async()=>{try{await l(a),await r.inDataExchange({data:t}),a.block!==e.block&&a.isKb===e.isKb&&await l(e),await r.inDataExchange({data:new i([176,e.block])})}catch(i){if(!c())throw i;await r.inDeselect({tg:1}).catch((()=>{}));const n={160:"write",176:"transfer",192:"decrement",193:"increment",194:"restore"}[t?.[0]]??`cmd(0x${t?.subarray(0,1)?.hex})`;throw new Error(`Failed to ${n} block from ${a.block} to ${e.block}`)}}))}async function b(){try{await s(),await r.inSelect({tg:1}),await r.writeRegisters({25346:0,25347:0}),await r.inCommunicateThru({data:new i([80,0,87,205])}).catch((()=>{})),await r.writeRegisters({25405:7}),await r.inCommunicateThru({data:new i([64])}),await r.writeRegisters({25405:0}),await r.inCommunicateThru({data:new i([67])})}catch(t){if(!c())throw t;throw new Error("Failed to open backdoor")}finally{c()&&await r.writeRegisters({25346:128,25347:128})}}async function m(t){return(await o((async()=>{try{return await r.inDataExchange(t)}catch(a){throw await w(),await b().catch((()=>{})),new Error(`Failed to read block ${t?.data?.[1]}`)}})))?.data}async function E(t){await o((async()=>{try{await r.inDataExchange(t)}catch(a){throw await w(),await b().catch((()=>{})),new Error(`Failed to write block ${t?.data?.[1]}`)}}))}async function p({block:t=0,data:a}={}){if(!i.isLen(a,16))throw new TypeError("invalid data");try{await b(),await E({data:new i([160,t,...a])})}finally{await w()}}return{inListPassiveTarget:s,mfAuthBlock:l,mfBackdoorGen1a:b,mfCheckKeys:async function({sectorMax:t=16,keys:a}={}){try{if(!(a=f(a)).length)throw new TypeError("invalid keys");const e=(await s())?.[0]?.uid;if(!e)throw new Error("Failed to select card");const i=Array(2*t).fill(null);for(let n=0;n<t;n++)for(let t=0;t<2;t++){const o=4*n+3;for(const s of a)try{await l({block:o,isKb:t,key:s,uid:e}),i[2*n+t]=s;break}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}}return i}finally{await w()}},mfDecrementBlock:async function({src:t,dist:a,int32:e=0}={}){for(const[e,r]of[["src",t],["dist",a]]){if(!i.isLen(r?.key,6))throw new TypeError(`invalid ${e}.key`);r.isKb=r?.isKb?1:0,r.block=r?.block??0}const r=new i([192,t.block,0,0,0,0]);r.setInt32(2,e);try{const e=(await s())?.[0]?.uid;if(!e)throw new Error("Failed to select card");await k(r,{...t,uid:e},{...a,uid:e})}finally{await w()}},mfIncrementBlock:async function({src:t,dist:a,int32:e=0}={}){for(const[e,r]of[["src",t],["dist",a]]){if(!i.isLen(r?.key,6))throw new TypeError(`invalid ${e}.key`);r.isKb=r?.isKb?1:0,r.block=r?.block??0}const r=new i([193,t.block,0,0,0,0]);r.setInt32(2,e);try{const e=(await s())?.[0]?.uid;if(!e)throw new Error("Failed to select card");await k(r,{...t,uid:e},{...a,uid:e})}finally{await w()}},mfKeysUniq:f,mfReadBlock:async function({block:t=0,isKb:a=0,key:e}={}){if(!i.isLen(e,6))throw new TypeError("invalid key");a=a?1:0;try{const r=(await s())?.[0]?.uid;if(!r)throw new Error("Failed to select card");return await l({block:t,isKb:a,key:e,uid:r}),await y({data:new i([48,t]),respValidator:u},{block:t,isKb:a,key:e,uid:r})}finally{await w()}},mfReadBlockGen1a:async function({block:t=0}={}){try{return await b(),await m({data:new i([48,t]),respValidator:u})}finally{await w()}},mfReadBlockKeyBA:async function({block:t=0,ka:a,kb:e}={}){try{const n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");for(let o=1;o>=0;o--)try{const r=[a,e][o];return await l({block:t,isKb:o,key:r,uid:n}),await y({data:new i([48,t]),respValidator:u},{block:t,isKb:o,key:r,uid:n})}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}throw new Error(`Failed to read block ${t}`)}finally{await w()}},mfReadCardByKeys:async function({sectorMax:a=16,keys:e}={}){if(!(e=f(e)).length)throw new TypeError("invalid keys");try{const n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");const o=new i(64*a),d={key:t.times(2*a,(()=>null)),read:t.times(4*a,(()=>0))};for(let t=0;t<a;t++){for(let a=0;a<2;a++)for(const s of e)try{await l({block:4*t,isKb:a,key:s,uid:n}),d.key[2*t+a]=s;for(let e=0;e<4;e++)try{const r=4*t+e;if(d.read[r])continue;const c=await y({data:new i([48,r]),respValidator:u},{block:4*t,isKb:a,key:s,uid:n});o.set(c,16*r),d.read[r]=1}catch(t){if(!c())throw t}break}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}for(let a=0;a<2;a++)d.key[2*t+a]&&o.set(d.key[2*t+a],64*t+[48,58][a])}return{data:o,success:d}}finally{await w()}},mfReadCardGen1a:async function({sectorMax:a=16}={}){try{await b();const e=new i(64*a),r=t.times(4*a,(()=>0));for(let t=0;t<a;t++)for(let a=0;a<4;a++)try{const n=4*t+a,o=await m({data:new i([48,n]),respValidator:u});e.set(o,16*n),r[n]=1}catch(t){if(!c())throw t}return{data:e,success:r}}finally{await w()}},mfReadSector:async function({sector:t=0,isKb:a=0,key:e}={}){if(!i.isLen(e,6))throw new TypeError("invalid key");a=a?1:0;try{const r=(await s())?.[0]?.uid;if(!r)throw new Error("Failed to select card");await l({block:4*t,isKb:a,key:e,uid:r});const n=new i(64),o=[0,0,0,0];for(let s=0;s<4;s++)try{const c=4*t+s,w=await y({data:new i([48,c]),respValidator:u},{block:4*t,isKb:a,key:e,uid:r});n.set(w,16*s),o[s]=1}catch(t){if(!c())throw t}return n.set(e,[48,58][a]),{data:n,success:o}}finally{await w()}},mfReadSectorGen1a:async function({sector:t=0}={}){try{await b();const a=new i(64),e=[0,0,0,0];for(let r=0;r<4;r++)try{const n=4*t+r,o=await m({data:new i([48,n]),respValidator:u});a.set(o,16*r),e[r]=1}catch(t){if(!c())throw t}return{data:a,success:e}}finally{await w()}},mfReadSectorKeyBA:async function({sector:t=0,ka:a,kb:e}={}){try{const n=new i(64),o={key:[0,0],read:[0,0,0,0]},d=(await s())?.[0]?.uid;if(!d)throw new Error("Failed to select card");for(let s=1;s>=0;s--)try{const r=[a,e][s];await l({block:4*t,isKb:s,key:r,uid:d}),o.key[s]=1;for(let a=0;a<4;a++)try{if(o.read[a])continue;const e=4*t+a,c=await y({data:new i([48,e]),respValidator:u},{block:4*t,isKb:s,key:r,uid:d});n.set(c,16*a),o.read[a]=1}catch(t){if(!c())throw t}}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}for(let t=0;t<2;t++)o.key[t]&&n.set([a,e][t],[48,58][t]);return{data:n,success:o}}finally{await w()}},mfRestoreBlock:async function({src:t,dist:a}={}){for(const[e,r]of[["src",t],["dist",a]]){if(!i.isLen(r?.key,6))throw new TypeError(`invalid ${e}.key`);r.isKb=r?.isKb?1:0,r.block=r?.block??0}const e=new i([194,t.block,0,0,0,0]);try{const i=(await s())?.[0]?.uid;if(!i)throw new Error("Failed to select card");await k(e,{...t,uid:i},{...a,uid:i})}finally{await w()}},mfSelectCard:async function({timeout:t}={}){try{return(await s({timeout:t}))?.[0]}finally{await w()}},mfSetUidGen1a:async function({atqa:t=null,sak:a=null,uid:e}={}){if(!i.isLen(e,4))throw new TypeError("invalid 4 bytes uid");const r=i.merge(e,new i([e.xor]),i.fromHex("080400000000000000BEAF"));i.isLen(a,1)&&r.set(a,5),i.isLen(t,2)&&r.set(t.slice().reverse(),6),await p({block:0,data:r})},mfSetUidGen2:async function({atqa:t=null,sak:a=null,uid:e,keys:n}={}){if(!i.isLen(e,4))throw new TypeError("invalid 4 bytes uid");if(!(n=f(n)).length)throw new TypeError("invalid keys");try{const o=(await s())?.[0]?.uid;if(!o)throw new Error("Failed to select card");const d=i.merge(e,new i([e.xor]),i.fromHex("080400000000000000BEAF"));i.isLen(a,1)&&d.set(a,5),i.isLen(t,2)&&d.set(t.slice().reverse(),6);let f=!1;for(let t=1;!f&&t>=0;t--)for(const a of n)try{await l({block:0,isKb:t,key:a,uid:o}),await h({data:new i([160,0,...d])},{block:0,isKb:t,key:a,uid:o}),f=!0;break}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}if(!f)throw new Error("Failed to write block 0")}finally{await w()}},mfWipeGen1a:async function({sectorMax:a=16,atqa:e=null,sak:r=null,uid:n}={}){try{if(!i.isLen(n,4))throw new TypeError("invalid 4 bytes uid");const o=t.times(4*a,(()=>0));await b();try{const t=i.merge(n,i.fromHex("00080400000000000000BEAF"));for(const a of n)t[4]^=a;i.isLen(r,1)&&t.set(r,5),i.isLen(e,2)&&t.set(e,6),await E({data:new i([160,0,...t])}),o[0]=1}catch(t){if(!c())throw t}const s=i.fromHex("00000000000000000000000000000000"),l=i.fromHex("FFFFFFFFFFFF08778F00FFFFFFFFFFFF");for(let t=0;t<a;t++){for(let a=t?0:1;a<3;a++)try{await E({data:new i([160,4*t+a,...s])}),o[4*t+a]=1}catch(t){if(!c())throw t}try{await E({data:new i([160,4*t+3,...l])}),o[4*t+3]=1}catch(t){if(!c())throw t}}return{success:o}}finally{await w()}},mfWriteBlock:async function({block:t=0,isKb:a=0,key:e,data:r}={}){if(!i.isLen(r,16))throw new TypeError("invalid data");if(!i.isLen(e,6))throw new TypeError("invalid key");a=a?1:0;try{const n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");await l({block:t,isKb:a,key:e,uid:n}),await h({data:new i([160,t,...r])},{block:t,isKb:a,key:e,uid:n})}finally{await w()}},mfWriteBlockGen1a:p,mfWriteBlockKeyBA:async function({block:t=0,ka:a,kb:e,data:n}={}){if(!i.isLen(n,16))throw new TypeError("invalid data");let o=!1;try{const d=(await s())?.[0]?.uid;if(!d)throw new Error("Failed to select card");for(let s=1;!o&&s>=0;s--)try{const r=[a,e][s];await l({block:t,isKb:s,key:r,uid:d}),await h({data:new i([160,t,...n])},{block:t,isKb:s,key:r,uid:d}),o=!0}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}if(!o)throw new Error(`Failed to write block ${t}`)}finally{await w()}},mfWriteCardByKeys:async function({sectorMax:a=16,keys:e,data:n}={}){if(!(e=f(e)).length)throw new TypeError("invalid keys");if(!i.isLen(n,64*a))throw new TypeError("invalid data");try{let o=(await s())?.[0]?.uid;if(!o)throw new Error("Failed to select card");const f=t.times(4*a,(()=>0));for(let t=0;t<a;t++){if(!d(n.subarray(64*t+54,64*t+57)))continue;let a=0;for(let d=1;4!==a&&d>=0;d--)for(const y of e)try{await l({block:4*t,isKb:d,key:y,uid:o});for(let e=0;e<4;e++)try{const r=4*t+e;if(f[r])continue;if(await h({data:new i([160,r,...n.subarray(16*r,16*r+16)])},{block:4*t,isKb:d,key:y,uid:o}),f[r]=1,a++,0===r&&(await w(),o=(await s())?.[0]?.uid,!o))throw new Error("Failed to select card")}catch(t){if(!c())throw t}break}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}}return{success:f}}finally{await w()}},mfWriteCardGen1a:async function({sectorMax:a=16,data:e}={}){if(!i.isLen(e,64*a))throw new TypeError("invalid data");try{await b();const r=t.times(4*a,(()=>0));for(let t=0;t<a;t++)for(let a=0;a<4;a++)try{const n=4*t+a;await E({data:new i([160,n,...e.subarray(16*n,16*n+16)])}),r[n]=1}catch(t){if(!c())throw t}return{success:r}}finally{await w()}},mfWriteSector:async function({sector:t=0,isKb:a=0,key:e,data:r}={}){if(!i.isLen(r,64))throw new TypeError("invalid data");if(!d(r.subarray(54,57)))throw new TypeError("invalid sector acl");if(!i.isLen(e,6))throw new TypeError("invalid key");try{let n=(await s())?.[0]?.uid;if(!n)throw new Error("Failed to select card");await l({block:4*t,isKb:a,key:e,uid:n});const o=[0,0,0,0];for(let l=0;l<4;l++)try{const c=4*t+l;if(await h({data:new i([160,4*t+l,...r.subarray(16*l,16*l+16)])},{block:4*t,isKb:a,key:e,uid:n}),o[l]=1,0===c&&(await w(),n=(await s())?.[0]?.uid,!n))throw new Error("Failed to select card")}catch(t){if(!c())throw t}return{success:o}}finally{await w()}},mfWriteSectorGen1a:async function({sector:t=0,data:a}={}){if(!i.isLen(a,64))throw new TypeError("invalid data");if(!d(a.subarray(54,57)))throw new TypeError("invalid sector acl");try{await b();const e=[0,0,0,0];for(let r=0;r<4;r++)try{const n=4*t+r;await E({data:new i([160,n,...a.subarray(16*r,16*r+16)])}),e[r]=1}catch(t){if(!c())throw t}return{success:e}}finally{await w()}},mfWriteSectorKeyBA:async function({sector:t=0,ka:a,kb:e,data:n}={}){if(!i.isLen(n,64))throw new TypeError("invalid data");if(!d(n.subarray(54,57)))throw new TypeError("invalid sector acl");try{let o=(await s())?.[0]?.uid;if(!o)throw new Error("Failed to select card");const d=[0,0,0,0];for(let f=1;f>=0;f--)try{const r=[a,e][f];await l({block:4*t,isKb:f,key:r,uid:o});for(let a=0;a<4;a++)try{if(d[a])continue;const e=4*t+a;if(await h({data:new i([160,e,...n.subarray(16*a,16*a+16)])},{block:4*t,isKb:f,key:r,uid:o}),d[a]=1,0===e&&(await w(),o=(await s())?.[0]?.uid,!o))throw new Error("Failed to select card")}catch(t){if(!c())throw t}}catch(t){if(!c())throw t;await r.inDeselect({tg:1}).catch((()=>{}))}return{success:d}}finally{await w()}},testIso14443Part4Present:async function(){let t=!1;return await o((async()=>{await r.inCommunicateThru({data:i.fromHex("B2")}),t=!0})),t}}}}}));
