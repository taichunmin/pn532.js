!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("lodash")):"function"==typeof define&&define.amd?define(["lodash"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).Pn532WebserialAdapter=t(e._)}(this,(function(e){"use strict";var t={};!function(e){var t;Object.defineProperty(e,"__esModule",{value:!0}),e.serial=e.SerialPort=e.SerialPolyfillProtocol=void 0,function(e){e[e.UsbCdcAcm=0]="UsbCdcAcm"}(t=e.SerialPolyfillProtocol||(e.SerialPolyfillProtocol={}));const i=[16,8,7,6,5],r=[1,2],s=["none","even","odd"],a=["none","odd","even"],n=[1,1.5,2],o={protocol:t.UsbCdcAcm,usbControlInterfaceClass:2,usbTransferInterfaceClass:10};function d(e,t){const i=e.configurations[0];for(const e of i.interfaces){if(e.alternates[0].interfaceClass===t)return e}throw new TypeError(`Unable to find interface with class ${t}.`)}function c(e,t){const i=e.alternates[0];for(const e of i.endpoints)if(e.direction==t)return e;throw new TypeError(`Interface ${e.interfaceNumber} does not have an ${t} endpoint.`)}class l{constructor(e,t,i){this.type="bytes",this.device_=e,this.endpoint_=t,this.onError_=i}pull(e){(async()=>{var t;let i;if(e.desiredSize){const t=e.desiredSize/this.endpoint_.packetSize;i=Math.ceil(t)*this.endpoint_.packetSize}else i=this.endpoint_.packetSize;try{const r=await this.device_.transferIn(this.endpoint_.endpointNumber,i);if("ok"!=r.status&&(e.error(`USB error: ${r.status}`),this.onError_()),null===(t=r.data)||void 0===t?void 0:t.buffer){const t=new Uint8Array(r.data.buffer,r.data.byteOffset,r.data.byteLength);e.enqueue(t)}}catch(t){e.error(t.toString()),this.onError_()}})()}}class u{constructor(e,t,i){this.device_=e,this.endpoint_=t,this.onError_=i}async write(e,t){try{const i=await this.device_.transferOut(this.endpoint_.endpointNumber,e);"ok"!=i.status&&(t.error(i.status),this.onError_())}catch(e){t.error(e.toString()),this.onError_()}}}class h{constructor(e,t){this.polyfillOptions_=Object.assign(Object.assign({},o),t),this.outputSignals_={dataTerminalReady:!1,requestToSend:!1,break:!1},this.device_=e,this.controlInterface_=d(this.device_,this.polyfillOptions_.usbControlInterfaceClass),this.transferInterface_=d(this.device_,this.polyfillOptions_.usbTransferInterfaceClass),this.inEndpoint_=c(this.transferInterface_,"in"),this.outEndpoint_=c(this.transferInterface_,"out")}get readable(){var e;return!this.readable_&&this.device_.opened&&(this.readable_=new ReadableStream(new l(this.device_,this.inEndpoint_,(()=>{this.readable_=null})),{highWaterMark:null!==(e=this.serialOptions_.bufferSize)&&void 0!==e?e:255})),this.readable_}get writable(){var e;return!this.writable_&&this.device_.opened&&(this.writable_=new WritableStream(new u(this.device_,this.outEndpoint_,(()=>{this.writable_=null})),new ByteLengthQueuingStrategy({highWaterMark:null!==(e=this.serialOptions_.bufferSize)&&void 0!==e?e:255}))),this.writable_}async open(e){this.serialOptions_=e,this.validateOptions();try{await this.device_.open(),null===this.device_.configuration&&await this.device_.selectConfiguration(1),await this.device_.claimInterface(this.controlInterface_.interfaceNumber),this.controlInterface_!==this.transferInterface_&&await this.device_.claimInterface(this.transferInterface_.interfaceNumber),await this.setLineCoding(),await this.setSignals({dataTerminalReady:!0})}catch(e){throw this.device_.opened&&await this.device_.close(),new Error("Error setting up device: "+e.toString())}}async close(){const e=[];this.readable_&&e.push(this.readable_.cancel()),this.writable_&&e.push(this.writable_.abort()),await Promise.all(e),this.readable_=null,this.writable_=null,this.device_.opened&&(await this.setSignals({dataTerminalReady:!1,requestToSend:!1}),await this.device_.close())}async forget(){return this.device_.forget()}getInfo(){return{usbVendorId:this.device_.vendorId,usbProductId:this.device_.productId}}reconfigure(e){return this.serialOptions_=Object.assign(Object.assign({},this.serialOptions_),e),this.validateOptions(),this.setLineCoding()}async setSignals(e){if(this.outputSignals_=Object.assign(Object.assign({},this.outputSignals_),e),void 0!==e.dataTerminalReady||void 0!==e.requestToSend){const e=(this.outputSignals_.dataTerminalReady?1:0)|(this.outputSignals_.requestToSend?2:0);await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:34,value:e,index:this.controlInterface_.interfaceNumber})}if(void 0!==e.break){const e=this.outputSignals_.break?65535:0;await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:35,value:e,index:this.controlInterface_.interfaceNumber})}}validateOptions(){if(!this.isValidBaudRate(this.serialOptions_.baudRate))throw new RangeError("invalid Baud Rate "+this.serialOptions_.baudRate);if(!this.isValidDataBits(this.serialOptions_.dataBits))throw new RangeError("invalid dataBits "+this.serialOptions_.dataBits);if(!this.isValidStopBits(this.serialOptions_.stopBits))throw new RangeError("invalid stopBits "+this.serialOptions_.stopBits);if(!this.isValidParity(this.serialOptions_.parity))throw new RangeError("invalid parity "+this.serialOptions_.parity)}isValidBaudRate(e){return e%1==0}isValidDataBits(e){return void 0===e||i.includes(e)}isValidStopBits(e){return void 0===e||r.includes(e)}isValidParity(e){return void 0===e||s.includes(e)}async setLineCoding(){var e,t,i;const r=new ArrayBuffer(7),s=new DataView(r);s.setUint32(0,this.serialOptions_.baudRate,!0),s.setUint8(4,n.indexOf(null!==(e=this.serialOptions_.stopBits)&&void 0!==e?e:1)),s.setUint8(5,a.indexOf(null!==(t=this.serialOptions_.parity)&&void 0!==t?t:"none")),s.setUint8(6,null!==(i=this.serialOptions_.dataBits)&&void 0!==i?i:8);if("ok"!=(await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:32,value:0,index:this.controlInterface_.interfaceNumber},r)).status)throw new DOMException("NetworkError","Failed to set line coding.")}}e.SerialPort=h;e.serial=new class{async requestPort(e,t){t=Object.assign(Object.assign({},o),t);const i=[];if(e&&e.filters)for(const r of e.filters){const e={classCode:t.usbControlInterfaceClass};void 0!==r.usbVendorId&&(e.vendorId=r.usbVendorId),void 0!==r.usbProductId&&(e.productId=r.usbProductId),i.push(e)}0===i.length&&i.push({classCode:t.usbControlInterfaceClass});const r=await navigator.usb.requestDevice({filters:i});return new h(r,t)}async getPorts(e){e=Object.assign(Object.assign({},o),e);const t=await navigator.usb.getDevices(),i=[];return t.forEach((t=>{try{const r=new h(t,e);i.push(r)}catch(e){}})),i}}}(t);const i=[{usbVendorId:1367,usbProductId:8200},{usbVendorId:1659,usbProductId:1211},{usbVendorId:1659,usbProductId:8963},{usbVendorId:1659,usbProductId:43682},{usbVendorId:1659,usbProductId:43683},{usbVendorId:6790,usbProductId:21795},{usbVendorId:6790,usbProductId:29986},{usbVendorId:6790,usbProductId:29987}];return class{_isOpen=!1;name="adapter";port=null;reader=null;install(r,s){const{pn532:a,utils:n}=r,o=this;if(a.$adapter)throw new Error("adapter already exists");function d(){return navigator?.serial??t.serial}async function c(){return!e.isNil(d())}function l(){return o._isOpen}async function u(){o._isOpen=!1,o.reader=null,o.port&&(await o.port.close().catch(console.error),o.port=null),n.logTime("device disconnected")}async function h(){o.reader&&await o.reader.cancel()}async function f(){try{if(!await c())throw new Error("WebSerial not supported");const e=d();if(o.port=await e.requestPort({filters:i}),!o.port)throw new Error("user canceled");const t=await o.port.getInfo();n.logTime(`port selected, usbVendorId = ${t.usbVendorId}, usbProductId = ${t.usbProductId}`),await o.port.open({baudRate:115200}),o._isOpen=!0,async function(){if(o?.port?.readable)try{for(o.reader=o.port.readable.getReader();;){const{value:e,done:t}=await o.reader.read();if(e){const t=a.rx.writable.getWriter();await t.write(e),t.releaseLock()}if(t)break}}catch(e){console.error(e)}finally{o.reader&&o.reader.releaseLock()}u()}(),await a.sendCommandWakeup(),await a.resetSettings()}catch(e){throw u(),e}}return a.tx=new TransformStream({flush:async e=>{await h(),e.terminate()},transform:async(e,t)=>{t.enqueue(e)}}),a.tx.readable.pipeTo(new WritableStream({write:async e=>{if(!o.port)throw new Error("me.port can not be null");const t=o.port.writable.getWriter();await t.write(e),t.releaseLock()}},new CountQueuingStrategy({highWaterMark:1}))),a.addMiddleware("writePacket",(async(e,t)=>(l()||await f(),await t()))),{connect:f,disconnect:h,isOpen:l,isSupported:c}}}}));
